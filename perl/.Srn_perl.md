Table of Contents
=================
* [I. Tutorial](#i-tutorial)
   * [1.1 Perldoc](#11-perldoc)
      * [options](#options)
   * [1.2 <a href="https://metacpan.org/pod/distribution/perl/pod/perldata.pod" rel="nofollow">perldata</a>](#12-perldata)
   * [1.2.1 Context](#121-context)
      * [1.2.2 scalar values](#122-scalar-values)
      * [1.2.2 List value constructors](#122-list-value-constructors)
      * [1.2.4 slice](#124-slice)
         * [1.2.5 Key/Value Hash Slices](#125-keyvalue-hash-slices)
      * [Typeglobs and Filehandles](#typeglobs-and-filehandles)
   * [perlsyn](#perlsyn)
   * [perlop](#perlop)
   * [perlre](#perlre)
   * [perlvar](#perlvar)
   * [perlsub](#perlsub)
   * [perlfunc](#perlfunc)
   * [perlmod](#perlmod)
   * [perlref](#perlref)
   * [perlobj](#perlobj)
   * [perlipc](#perlipc)
   * [perlrun](#perlrun)
   * [perldebug](#perldebug)
   * [perldiag](#perldiag)
   * [perlfaq](#perlfaq)
      * [perlfaq1](#perlfaq1)
      * [<a href="https://metacpan.org/pod/distribution/perlfaq/lib/perlfaq5.pod" rel="nofollow">perlfaq5 - Files and Formats</a>](#perlfaq5---files-and-formats)
* [II. Modules:](#ii-modules)
   * [2.1 File::Copy](#21-filecopy)
   * [2.2 perl common modules simple usage sample](#22-perl-common-modules-simple-usage-sample)
* [III. Doc:](#iii-doc)
   * [3.1 Truth and Falsehood](#31-truth-and-falsehood)
   * [3.2 -&gt; 用法](#32---用法)
   * [3.3 <a href="http://stackoverflow.com/questions/7083453/copying-a-hashref-in-perl" rel="nofollow">copy hash</a>](#33-copy-hash)


# I. Tutorial #
## 1.1 Perldoc
### options
<blockquote>
-q perlfaq-search-regexp <br>
The -q option takes a regular expression as an argument.  It will search the question headings in perlfaq[1-9] and print the entries matching the regular expression.
</blockquote>

<blockquote>
-v perlvar
    The -v option followed by the name of a Perl predefined variable will extract the documentation of this variable from perlvar.
```perl
    perldoc -v '$"'
    perldoc -v '$#'
```
</blockquote>

<blockquote>
PageName|ModuleName|ProgramName|URL <br>
The item you want to look up.  Nested modules (such as "File::Basename") are specified either as "File::Basename" or "File/Basename".
</blockquote>

<blockquote>
-m module
    Display the entire module: both code and unformatted pod documentation.  This may be useful if the docs don't explain a function in the detail you need, and you'd like to inspect the code directly; perldoc will find the file for you and simply hand it off for display.
</blockquote>

## 1.2 [perldata](https://metacpan.org/pod/distribution/perl/pod/perldata.pod)

> Perl has three built-in data types: scalars, arrays of scalars, and associative arrays of scalars, known as "hashes".
 - A scalar is a single string (of any size, limited only by the available memory), number, or a reference to something (which will be discussed in perlref).
 - Normal arrays are ordered lists of scalars indexed by number, starting with 0.
 - Hashes are unordered collections of scalar values indexed by their associated string key.

> Values are usually referred to by name, or through a named reference. The first character of the name tells you to what sort of data structure it refers. The rest of the name tells you the particular value to which it refers.

scalar values are named with '$', even when referring to a scalar that is part of an array or a has. (like the English word "the") indicates a single value is expected.

```perl
$days
$days[28]
$days{'Feb'}
$#days            #the last index of array @days
```

Entire arrays are denoted by '@' (like the "these" or "those" does in English)
```perl
@days[3,4,5] # same as($days[3],$days[4],$days[5])
@days{'a','c'}   # same as ($days{'a'},$days{'c'})
```

Entire hashes are denoted by '%'

## 1.2.1 Context
The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar.

### 1.2.2 scalar values
All data in Perl is a scalar, an array of scalars, or a hash of scalars.
A scalar may contain one single value in any of three different flavors: a number, a string, or a reference.
Although a scalar may not directly hold multiple values, it may contain a reference to an array or hash which in turn contains multiple values.

> A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, "0"), and TRUE if it is anything else.

truncate an array to nothing:
```perl
@wahtever = ();
$#whatever = -1;
```

If you evaluate an array in scalar context, it returns the length of the array.
```perl
$element_count = scalar(@wahtever);
```

### 1.2.2 List value constructors
LISTs do automatic interpolation of sublists. That is, when a LIST is evaluated, each element of the list is evaluated in list context, and the resulting list value is interpolated into LIST just as if each individual element were a member of LIST.
```perl
(@foo, &SomeSub, %glarch)
```

A list value may also be subscripted like a normal array.
```perl
$time = (stat($file))[8];
```

An exception to this is that you may assign to undef in a list. This is useful for throwing away some of the return values of a function:
```perl
($dev, $ino, undef, undef, $uid, $gid) = stat($file);
```

The final element of a list assignment may be an array or a hash:
```perl
($a, $b, @rest) = split;
my ($a, $b, %rest) = @_;
```

It is often more readable to use the => operator between key/value pairs.
```perl
%map = (
    red => 0x00f,
    blue => 0x0f0,
    );
```

initializing hash referencese:
```perl
    $rec = {
        date => '10/31',
        cat => 'moew',
    };
```

### 1.2.4 slice
```perl
($who, $home)  = @ENV{"USER", "HOME"};      # hash slice
@them          = @folks[0 .. 3];            # array slice
```

#### 1.2.4.1 Key/Value Hash Slices
Starting from Perl 5.20 support
```perl
%h = (blonk => 2, foo => 3, squink => 5, bar => 8);
%subset = %h{'foo', 'bar'}; # key/value hash slice
## %subset is now (foo => 3, bar => 8)
```

### 1.2.5 Typeglobs and Filehandles
Perl uses an internal type called a typeglob to hold an entire symbol table entry. 
The type prefix of a typeglob is a `*` , because it represents all types.
```perl
local *Here::blue = \$There::green;
```
> temporarily makes `$Here::blue` an alias for `$There::green`, but doesn't make @Here::blue an alias for @There::green, or %Here::blue an alias for %There::green, etc.


## 1.3 [perlop](https://metacpan.org/pod/release/XSAWYERX/perl-5.30.0/pod/perlop.pod)

## perlre

## perlvar

## perlsub

## perlfunc

## perlmod

## perlref

## perlobj

## perlipc

## perlrun

## perldebug

## perldiag

## perlfaq
### perlfaq1

### [perlfaq5 - Files and Formats](https://metacpan.org/pod/distribution/perlfaq/lib/perlfaq5.pod)

---
# II. Modules: #
## 2.1 File::Copy 
>'cp' and 'mv' would keep permission comparing to the 'copy' and 'move'
https://metacpan.org/source/SHAY/perl-5.22.1/lib/File/Copy.pm

## 2.2 perl common modules simple usage sample
http://bbs.chinaunix.net/thread-85748-5-1.html

---
# III. Doc: #
## 3.1 Truth and Falsehood
> The number 0, the strings '0' and "", the empty list "()", and "undef"
are all false in a boolean context.  All other values are true.
Negation of a true value by "!" or "not" returns a special false value.
When evaluated as a string it is treated as "", but as a number, it is
treated as 0.  Most Perl operators that return true or false behave
this way.

## 3.2 -> 用法
-> 有两种用法，都和解引用有关。

- 1. List item
 第一种用法，就是解引用。
 根据 -> 后面跟的符号的不同，解不同类型的引用，
 ->[] 表示解数组引用，->{} 表示解散列引用 ，->() 表示解子例程引用。
 例子：
```perl
$arr_ref = \@array;
$arr_ref->[0] 访问数组 @array 的第一个元素。
$hash_ref = \%hash;
$hash_ref->{foo} 访问 %hash 的 foo 分量
$sub_ref = \&test;
$sub_ref->(1, 2, 3) 使用参数列表 (1,2,3) 来调用 &test 这个子程序。
```

- 2. 第二种用法，就是调用类或者对象的方法(_method_)。
格式：
> $obj->method();
或者
> ClassName->method();

例如：
```perl
$pop3->login( $username, $password );
my $ftp = Net::FTP->new("some.host.name", Debug => 0);
```
这两种用法略有不同，
但是总的来说，符合以下规则：
>假设 -> 的左操作数（就是左边那个值，如 $pop3 和 Net::FTP）是 $left，右操作数（就是右边那个值，如 login 和 new）是 $right，那么 -> 的运算规则就是：
```perl
 if ( ref $left 有效 ){    # 也就是说 $left 是个引用，而不是个裸字
         $ClassName = ref $left;   # 取引用的类型，当作类名称
 } else{
         $ClassName = $left;       # 直接把裸字当作类名称
 }
```
 然后调用：

```perl
 &{$ClassName::$right}($left, 原参数列表) 
```
 也就是说把类名称和右操作数拼在一起，当作子程序名称（注），并把左操作数当作第一个参数。

注：Perl 解释器要做的工作其实要比这复杂，它还要考虑到继承的问题。

## 3.3 [copy hash](http://stackoverflow.com/questions/7083453/copying-a-hashref-in-perl)
You can create a shallow copy of a hash easily:
```perl
my $copy = { %$source };
```
The %$source bit in list context will expand to the list of key value pairs. The curly braces (the anonymous hash constructor) then takes that list an creates a new hashref out of it. A shallow copy is fine if your structure is 1-dimensional, or if you do not need to clone any of the contained data structures.

To do a __full deep__ copy, you can use the core module Storable.
```perl
use Storable 'dclone';
my $deep_copy = dclone $source;
```

---

