# module:

# exp:

# lessons:
## generator: retrun an iterator (generator iterator), call be "next()" to execute until it raises an exception
use () to generate a generator object
g = ( x*x for x in range(100) )

## decorators: a function use function as input arguments to add addition feature without modify original function

#### function decorator
```python
import time
def decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        func()
        end_time = time.time()
        print(end_time - start_time)

    return wrapper

@decorator
def func():
    time.sleep(1)

func()
```

# quiz:
### 1. sum
``` python
    sum(range(1,101))
```

### 2. change global var in function
```python
g_a = 5
def fn():
    global g_a
    g_a = 7
fn()
```

### 3. del key and merge dicts
```python
dic = {"name": "aa", "age": 18}
del dic['age']
dic2 = {"name": "ls"}
dic.update(dic2)
```

### 4. GIL


### 5. remove duplicated items in list
```python
l = [1, 2, 3, 5, 7, 3, 2, 1]
[x for x in set(l)]
```

### 6. \*\*kwargs and \*args (mutable arguments passed to function)
def demo(**args_v):
    for k,v in args_v.items():
        print k,v


### 8. __new__ and __init__
+ __init__ initial method, immediately call by the object is created, could pass arguments
+ __new__ need at least one argument cls (current classs)
    - must have return value, return instance object (call __init__ automatically)

```python
class A(object):
    def __init__(self):
        print ("this is init method", self)

    def __new__(cls):
        print ("this is cls id", id(cls))
        print ("this is new method", object.__new__(cls))
        return object.__new__(cls)

A()
print ("this is A ID, id(A))
```

### 9. map(...): map(function, sequence[, sequence, ...]) -> list
```python
list = [1, 2, 3, 4, 5]
[x for x in map(lambda x: x**2, list) if x > 10]
```









