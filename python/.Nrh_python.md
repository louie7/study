# I. Module: #
## collections
### counter: A Counter is a dict subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values. 
- Elements are counted from an iterable or initialized from another mapping (or counter):
```python
from collections import Counter
c = Counter()                           # a new, empty counter
c = Counter('gallahad')                 # a new counter from an iterable
c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping
c = Counter(cats=4, dogs=8)             # a new counter from keyword args

## Counter objects support three methods beyond those available for all dictionaries:

```

---
# II. Doc #
## 9. class ##
### 9.2 scope and namespace
#### namespace
- A namespace is a mapping from names to objects
    samples: built-in, global, local
    there is absolutely no relation between names in different namespaces;
    in the expression z.real, real is an attribute of the object z
- namespaces are created at different moments and have different lifetimes 
    The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted.
    global namespace for a module is created when the module definition is read in
    The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. recursive invocations each have their own local namespaces
- at any time during execution, there are at least three nested scopes whose namespaces are directly accessible:
    + the innermost scope, which is searched first, contains the local names
    + the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names
    + the next-to-last scope contains the current module’s global names
    + the outermost scope (searched last) is the namespace containing built-in names

- A special quirk of Python is that – if no global statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. 


# III. Lessons #
## generator: retrun an iterator (generator iterator), call be "next()" to execute until it raises an exception
```python
use () to generate a generator object
g = ( x*x for x in range(100) )
```

## decorators: a function use function as input arguments to add addition feature without modify original function

#### function decorator
```python
import time
def decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        func()
        end_time = time.time()
        print(end_time - start_time)

    return wrapper

@decorator
def func():
    time.sleep(1)

func()
```

# IV. Quiz #
### 1. sum
``` python
    sum(range(1,101))
```

### 2. change global var in function
```python
g_v = 5
def fn():
    global g_v
    g_v = 7
fn()
```

### 3. del key and merge dicts
```python
dic = {"name": "aa", "age": 18}
del dic['age']
dic2 = {"name": "ls"}
dic.update(dic2)
```

### 4. GIL


### 5. remove duplicated items in list
```python
l = [1, 2, 3, 5, 7, 3, 2, 1]
[x for x in set(l)]
```

### 6. \*\*kwargs and \*args (mutable arguments passed to function)
```python
def demo(**args_v):
    for k,v in args_v.items():
        print k,v
```



### 8. \_\_new\_\_ and \_\_init\_\_
+ \_\_init\_\_ initial method, immediately call by the object is created, could pass arguments
+ \_\_new\_\_ need at least one argument cls (current classs)
    - must have return value, return instance object (call \_\_init\_\_ automatically)

```python
class A(object):
    def __init__(self):
        print ("this is init method", self)

    def __new__(cls):
        print ("this is cls id", id(cls))
        print ("this is new method", object.__new__(cls))
        return object.__new__(cls)

A()
print ("this is A ID, id(A))
```

### 9. map(...): map(function, sequence[, sequence, ...]) -> list
```python
list = [1, 2, 3, 4, 5]
[x for x in map(lambda x: x**2, list) if x > 10]
[ x * x for x in [1,2,3,4,5] if x * x > 10 ]
```

### 10. filter(...): filter(function or None, sequence) -> list, tuple, or string
```python
list = [1, 2, 3, 4, 5]
[x for x in list if x % 2 != 0]
filter(lambda x: x % 2 != 0, list]
```

### 11. mutable and immutable type
- immutable: int, string, tuple
    + only one object in mem for same value, value could be changed
- mutable: list, dcit
    + value could be changed (append, etc), only change the value, would not create new object
    + same value for different objects, they are different objects in mem


### 12. sort list by removing redundant char
```python
# sorted(...)
#   sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
a = 'ajldjlajfdljfddd'
''.join(sorted([x for x in set(a)]))
```

### 13. sort dict key
> D.items() -> list of D's (key, value) pairs, as 2-tuples
```python
d = {'name': 'aa', 'age': 18, 'city': 'sh'}
new_d ={}
for i in sorted(d.items(), key=lambda i:i[0]):
    print("{} ==> {}".format(i[0],i[1]))
    new_d[i[0]]=i[1]
```


### 14. timestamp
```python
>>> import datetime
>>> datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
'2019-04-23 08:52:12'
```

### 15. statistic lib: pyecharts, matplotlib
- https://github.com/pyecharts/pyecharts


### 16. list operation
#### a. extend list
```python
l = [[1, 2], [3, 4], [5, 6]]
[x for i in l for x in i]
```
